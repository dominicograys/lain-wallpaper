<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serial Experiments Lain Visualizer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: #00ff41;
            font-family: 'Courier Prime', monospace;
            overflow: hidden;
            height: 100vh;
        }
        .container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .scanlines {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(transparent 50%, rgba(0, 255, 65, 0.03) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            animation: scanlines 0.1s linear infinite;
        }
        @keyframes scanlines { 0% { transform: translateY(0); } 100% { transform: translateY(4px); } }
        .noise {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            opacity: 0.02;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><defs><filter id="noise"><feTurbulence baseFrequency="0.9" numOctaves="1" result="noise"/><feColorMatrix in="noise" type="saturate" values="0"/></filter></defs><rect width="100%" height="100%" filter="url(%23noise)"/></svg>');
            animation: noise 0.2s steps(10) infinite;
        }
        @keyframes noise {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-5%, -5%); }
            20% { transform: translate(-10%, 5%); }
            30% { transform: translate(5%, -10%); }
            40% { transform: translate(-5%, 15%); }
            50% { transform: translate(-10%, 5%); }
            60% { transform: translate(15%, 0%); }
            70% { transform: translate(0%, 15%); }
            80% { transform: translate(-15%, 10%); }
            90% { transform: translate(10%, 5%); }
        }
        .main-text {
            font-size: 3rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 2rem;
            text-shadow: 0 0 10px #00ff41;
            animation: glitch 2s infinite;
        }
        @keyframes glitch {
            0%, 90%, 100% { transform: translate(0); filter: hue-rotate(0deg); }
            10% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
            20% { transform: translate(-2px, -2px); filter: hue-rotate(180deg); }
            30% { transform: translate(2px, 2px); filter: hue-rotate(270deg); }
            40% { transform: translate(2px, -2px); filter: hue-rotate(360deg); }
        }
        .terminal {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff41;
            padding: 20px; margin: 20px;
            min-width: 60%; max-width: 80%;
            font-size: 1.2rem;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
        }
        .terminal-header {
            border-bottom: 1px solid #00ff41;
            padding-bottom: 10px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
        }
        .matrix-rain {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: -1;
        }
        .matrix-column {
            position: absolute; top: -100%;
            color: #00ff41;
            font-size: 18px;
            animation: matrix-fall linear infinite;
            opacity: 0.6;
        }
        @keyframes matrix-fall { to { transform: translateY(100vh); } }
        .cursor { animation: blink 1s infinite; }
        @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }
        .error-text { color: #ff0040; text-shadow: 0 0 5px #ff0040; }
        .status-bar {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: rgba(0, 255, 65, 0.1);
            padding: 10px;
            font-size: 0.9rem;
            border-top: 1px solid #00ff41;
        }
        .wired-text {
            animation: wired-glow 3s ease-in-out infinite alternate;
        }
        @keyframes wired-glow {
            from { text-shadow: 0 0 5px #00ff41, 0 0 10px #00ff41, 0 0 15px #00ff41; }
            to { text-shadow: 0 0 10px #00ff41, 0 0 20px #00ff41, 0 0 30px #00ff41; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="scanlines"></div>
        <div class="noise"></div>
        <div class="matrix-rain"></div>

        <div class="main-text wired-text">
            PRESENT DAY<br>PRESENT TIME
        </div>

        <div class="terminal">
            <div class="terminal-header">
                <span>NAVI://SYSTEM.EXE</span>
                <span>LAYER:07</span>
            </div>
            <div class="content" id="terminal-output">
                <div>$ whoami</div>
                <div>LAIN_IWAKURA</div>
                <div>$ ls -la /wired/</div>
                <div>drwxr-xr-x 2 lain users 4096 Jul 07 1998 knights/</div>
                <div>-rw-r--r-- 1 lain users 2048 Jul 07 1998 protocol.dat</div>
                <div class="error-text">ERROR: Reality boundary overflow</div>
                <div>$ connect --wired</div>
                <div class="wired-text">Connecting to the Wired...</div>
                <div>Connection established.</div>
                <div>You are now part of the Wired<span class="cursor">_</span></div>
            </div>
        </div>

        <div class="status-bar">
            <span>Status: CONNECTED | Protocol: 7 | Reality Level: UNDEFINED | User: LAIN</span>
        </div>
    </div>

    <script>
        function createMatrixRain() {
            const matrixContainer = document.querySelector('.matrix-rain');
            const characters = '01„Ç¢„Ç§„Ç¶„Ç®„Ç™„Ç´„Ç≠„ÇØ„Ç±„Ç≥„Çµ„Ç∑„Çπ„Çª„ÇΩ„Çø„ÉÅ„ÉÑ„ÉÜ„Éà„Éä„Éã„Éå„Éç„Éé„Éè„Éí„Éï„Éò„Éõ„Éû„Éü„É†„É°„É¢„É§„É¶„É®„É©„É™„É´„É¨„É≠„ÉØ„É≤„É≥';
            for (let i = 0; i < 50; i++) {
                const column = document.createElement('div');
                column.className = 'matrix-column';
                column.style.left = Math.random() * 100 + '%';
                column.style.animationDuration = (Math.random() * 3 + 2) + 's';
                column.style.animationDelay = Math.random() * 2 + 's';
                let columnText = '';
                for (let j = 0; j < 20; j++) {
                    columnText += characters[Math.floor(Math.random() * characters.length)] + '<br>';
                }
                column.innerHTML = columnText;
                matrixContainer.appendChild(column);
            }
        }

        function glitchText() {
            const mainText = document.querySelector('.main-text');
            const originalText = mainText.innerHTML;
            const glitchChars = '!@#$%^&*(){}[]<>?/.,;:"';
            setInterval(() => {
                if (Math.random() < 0.1) {
                    let glitched = originalText;
                    for (let i = 0; i < 3; i++) {
                        const pos = Math.floor(Math.random() * originalText.length);
                        const glitchChar = glitchChars[Math.floor(Math.random() * glitchChars.length)];
                        glitched = glitched.substring(0, pos) + glitchChar + glitched.substring(pos + 1);
                    }
                    mainText.innerHTML = glitched;
                    setTimeout(() => {
                        mainText.innerHTML = originalText;
                    }, 100);
                }
            }, 500);
        }

        function typeInTerminal() {
            const commands = [
                '$ ping reality.exe',
                'PING reality.exe: Host unreachable',
                '$ sudo rm -rf /ego/*',
                'Permission granted. Ego deleted.',
                '$ echo "Who am I?"',
                'Lain is Lain. Lain of the Wired.',
                '$ ./love_machine.sh',
                'Love machine activated...',
                'Connection to all humans established.',
                '$ exit',
                'You cannot leave the Wired.'
            ];
            let commandIndex = 0;
            const terminal = document.querySelector('#terminal-output');
            setInterval(() => {
                if (commandIndex < commands.length && Math.random() < 0.3) {
                    const newLine = document.createElement('div');
                    newLine.textContent = commands[commandIndex];
                    if (commands[commandIndex].includes('ERROR') || commands[commandIndex].includes('unreachable')) {
                        newLine.className = 'error-text';
                    }
                    terminal.appendChild(newLine);
                    commandIndex++;
                    while (terminal.children.length > 15) {
                        terminal.removeChild(terminal.firstChild);
                    }
                }
            }, 3000);
        }

        function screenFlicker() {
            const body = document.body;
            setInterval(() => {
                if (Math.random() < 0.05) {
                    body.style.filter = 'brightness(0.3) contrast(3)';
                    setTimeout(() => {
                        body.style.filter = 'none';
                    }, 50);
                }
            }, 1000);
        }

        // üß¨ NEW: Fetch latest Solana block and display in terminal
        async function fetchLatestSolanaBlock() {
            try {
                const res = await fetch("https://api.mainnet-beta.solana.com", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        "jsonrpc":"2.0",
                        "id":1,
                        "method":"getLatestBlockhash"
                    })
                });
                const data = await res.json();
                const blockhash = data.result.value.blockhash;
                const line = document.createElement('div');
                line.textContent = `Solana Blockhash: ${blockhash}`;
                document.querySelector('#terminal-output').appendChild(line);
            } catch (err) {
                const errLine = document.createElement('div');
                errLine.textContent = 'Failed to fetch Solana block';
                errLine.className = 'error-text';
                document.querySelector('#terminal-output').appendChild(errLine);
            }
        }

        // INIT all
        createMatrixRain();
        glitchText();
        typeInTerminal();
        screenFlicker();
        fetchLatestSolanaBlock();

        // Optional: auto-refresh blockhash every 30s
        setInterval(fetchLatestSolanaBlock, 30000);
    </script>
</body>
</html>
